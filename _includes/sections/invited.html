<div class="container" id="i18_invited">
    <div class="row m-b-lg">
        <div class="col-lg-12 text-center">
            <div class="navy-line"></div>
            <h1><span data-i18n="projects.invited">Invited Speakers (To be confirmed)</span></h1>
        </div>
    </div>

<p>
<h1><strong> Simon Jones (University of the West of England) </strong> </h1>
	<p style = " position: fixed; top: 50%; left: -50%;">
	<h2><strong>Onboard Evolution of Understandable Swarm Behaviours</strong></h2>
		<p align="left" style= "cmax-width:600px; word-wrap:break-word;">
		Designing the individual robot rules that give rise to emergent swarm behaviours is difficult. <br>
		The common method of running evolutionary algorithms to automatically discover controllers <br>
		in simulation suffers from a major disadvantage; the evolved controllers are often opaque <br>
		and hard to understand. We use behaviour trees as the controller architecture because they <br>
		are modular, hierarchical and human understandable. We evolve fit controllers in a swarm with <br>
		high processing power, use automatic tools to simplify them, and then explain them, an important <br>
		factor for safety and acceptance. We look at the design of a suitable behaviour tree architecture, <br> 
		applying the techniques of Genetic Programming to behaviour trees, the implementation of a fast <br>
		 parallel simulator and tree interpreter running on the GPUs of our swarm of robots, how large <br>
		 evolved trees can be automatically simplified to aid analysis, and then explain one of the <br>
		 evolved controllers. 
		</p>

	</p>
</p>

<p>
</br>
<h1><strong> Vincent Berenz (Max Planck Institute for Intelligent Systems) </strong> </h1>
	<p style = " position: fixed; top: 50%; left: -50%;">
	<h2><strong>Behavioral Reactivity: Using Reactive Programming to Create Behavior Trees</strong></h2>
		<p align="left" style= "cmax-width:400px; word-wrap:break-word;">
We will present how to apply reactive programming to the design of robot behavior tree. <br> 
Using this paradigm, user defines branches and then associate them with rules of activation. <br>
Contrary to other approaches, the behavior tree is not traversed at runtime. Rather the branches <br>
compete continuously one with another for activation. And because branches can be attached to <br>
targets (discretized high level sensor entities), the activation of a branch will correspond to <br> 
the activation of a specific set of sensory motor couplings that will shape the behavior of the robot.<br>
As various videos will show, this programming paradigm supports rich and complex behaviors <br> 
characterized by high behavioral reactivity. Playful, our open-source reactive programming <br>
interpreter supporting behavior trees, will be introduced. Our more recent work exploring <br> 
the automated generation of reactive programming scripts from human demonstration will also be discussed.
		</p>
	</p>
</p>


</br>
<p>
</br>
<h1><strong> Chris Paxton (NVIDIA) </strong> </h1>
	<p style = " position: fixed; top: 50%; left: -50%;">
	<h2><strong>Building Reactive Task Plans for Real-World Robot Applications</strong></h2>
		<p align="left" style= "cmax-width:400px; word-wrap:break-word;">
                        Robots are increasingly an important part of our world, from working in factories and hospitals <br>
			to driving on city streets. As robots move into more unstructured environments such as homes, <br>
			however, we must be able to create complex, reactive task plns that can deal with stochastic <br>
			actions, unreliable sensors, and that above all are intuitive and easy to build. To this end, <br>
			we created the Behavior Tree-based CoSTAR system -- which allows novice end users to create <br>
			task plans for industrial robot task plans, shown in a 35-person user study to be highly <br>
			user friendly and offer a useful set of tools for creating task plans. <br>
			We also describe a variant on Behavior Trees, the Robust Logical-Dynamical System (RLDS), <br>
			which supports symbolic task planning and guarantees on performance. Finally, we describe a <br>
			manipulation case study on an example of an unstructured household manipulation task. <br>
		</p>
	</p>
</p>
<p>
<h1><strong> Francesco Rovida (Aalborg University) </strong> </h1>




	<p style = " position: fixed; top: 50%; left: -50%;">
	<h2><strong>Practical application of Behavior trees for industrial robot task design</strong></h2>
		<p align="left" style= "cmax-width:400px; word-wrap:break-word;">
Reconfigure collaborative robots on new tasks quickly and efficiently is today one <br>
of the great challenges for manufacturing industries. In this respect, behavior trees<br>
already proved to be a great tool to design and execute complex coordination schemes<br>
that are hierarchical, highly modular and with a predicable outcome. Nevertheless,<br>
being a state-less logic in their classical form, BT have more problems representing <br>
sequences w.r.t. other approaches such as e.g. FSMs. In this presentation we will see <br>
how we adapted the classical BT model to fit in a working framework that encompases <br>
dynamic planning, BTs optimization and knowledge management.
		</p>
	</p>

</p>
</br>
<p>
<h1><strong> Enrique Coronado (Tokyo University of Agriculture and Technology) </strong> </h1>
</p>
</br>

</div>
<br>
